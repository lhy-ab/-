# 自顶向下分析概述

### 自顶向下分析

从分析树顶部（根节点）向底部（叶节点）方向构造分析书，也就是从文法开始符号S推导出词串w的过程。

例子：

![](C:\Users\27923\Desktop\编译原理\微信截图_20241231135632.png)

每一次推导，需要决定替换哪个非终结符以及用该非终结符的哪个候选式进行替换

### 最左推导

在推导中，总是选择每个句型的最左非终结符进行替换

例子：

![](C:\Users\27923\Desktop\编译原理\微信截图_20241231140215.png)

### 最右推导

在推导中，总是选择每个句型的最右非终结符进行替换

![](C:\Users\27923\Desktop\编译原理\微信截图_20241231140456.png)

在自底向上的分析中，总是采用最左规约方式，所以最左规约可称为规范规约，最右推导称为规范推导

### 最左推导和最右推导的唯一性

对于每一个分析树，最左推导和最右推导都是唯一的

### 自顶向下的语法分析采用最左推导方式

总是选择每个句型的最左非终结符进行替换，并根据输入流中的下一个终结符选择最左非终结符的一个候选式

例子：

![](C:\Users\27923\Desktop\编译原理\微信截图_20241231142155.png)

### 自顶向下语法分析通用形式：递归下降分析

有一组过程组成，每个过程对应一个非终结符

![](C:\Users\27923\Desktop\编译原理\微信截图_20241231143333.png)

从文法开始符号S对应的过程开始，其中递归调用文法中其他非终结符对应的过程。如果S对应的过程体恰好扫描了整个输入串，则成功完成了语法分析

同时的，若示例中A有多个候选式，则需要按照一定顺序逐个尝试，若尝试失败，需要退回到上一步，选择A开头的其他候选式，因此这个退回并另选候选式的过程叫做回溯，这会导致分析器的效率降低。

### 预测分析

这是递归下降分析的一个特例，通过在输入中向前看固定个数（一般是一个）符号来选择正确的产生式

可以对某些文法构造出向前看k个输入符号的预测分析器，该类文法也称之为LL（k）文法类

预测分析不需要回溯，是一种确定的自顶向下分析方法

# 文法转换

含有A→Aɑ形式产生的文法是直接左递归的，如果一个文法中有一个非终结符A使得对某个串ɑ存在一个推导A→⁺Aɑ，那么这个文法就是左递归的，经过两步或两步以上推导产生的左递归成为是间接左递归的

左递归文法回使递归下降分析器陷入无限循环

消除左递归的方法就是将左递归转换成右递归

### 消除左递归的一般形式

![](C:\Users\27923\Desktop\编译原理\微信截图_20241231151027.png)

将左递归转换成右递归需要引进一些非终结符和ɛ_产生式

对于部分间接左递归可采用将定义式带入的方法，使之产生直接左递归

例子：

![](C:\Users\27923\Desktop\编译原理\微信截图_20241231151823.png)

### 提取左公因子

在文法中，若同一非终结符的的多个候选式存在相同前缀，会导致回溯现象对于此类问题，可采取提取左工因子的方法

例子：

转换前：

![](C:\Users\27923\Desktop\编译原理\微信截图_20241231152924.png)

转换后：

![](C:\Users\27923\Desktop\编译原理\微信截图_20241231152935.png)

此方法改写了产生式，使之推迟决定，等读入了足够多的输入，获得足够信息后在做出正确的选择

# LL(1)文法：

### 预测分析法的工作过程

从文法开始符号出发，在每一步推导过程中根据当前句型的最左非终结符A和当前输入符号a，选择正确的A-产生式。为保证分析的确定性，选出的候选式必须是唯一的。

### 什么时候使用ε产生式

如果当前某非终结符A与当前输入符a不匹配时，若存在A→ε，可以通过检查a是否可以出现在 A的后面（检查A的follow集），来决定是否使用产生式 A→ε（若文法中无 A→ε ，则应报错）

### Follow集

可能在某个句型中紧跟在A后边的终结符a的集合，记FOLLOW(A)，FOLLOW(A）={a|S→αAaβ, a∈VT，α,β∈(VT∪VN)*}

若A是某个句型的的最右符号，则将结束符“$”添加到FOLLOW(A)中

若A是某个句型的的最右符号，则FOLLOW(A)依赖于该产生式的左部FOLLOW集

### First集

给定一个文法符号串α， α的串首终结符集FIRST(α)被定义为可以从α推导出的所有串首终结符构成的集合。如果α→*ε，那么ε也在FIRST(α)中

### Select集

产生式A→β的可选集是指可以选用该产生式进行推导时对应的输入符号的集合，记为SELECT( A→β)

产生式A→α的可选集SELECT：

如果 ε∉FIRST(α), 那么SELECT(A→α)= FIRST(α)

如果 ε∈FIRST(α), 那么SELECT(A→α)= ( FIRST(α)-{ε} )∪FOLLOW(α)

### S_文法

每个产生式的右部都以终结符开始，同一非终结符的各个候选式的首终结符都不同，且S_文法不含空产生式

### q_文法

每个产生式的右部或为ε ，或以终结符开始，且具有相同左部的产生式有不相交的可选集

该文法不含右部以非终结符打头的产生式

### LL(1)文法

当且仅当该文法中任意两个具有相同左部的产生式A →α | β 满足下面的条件：

1.不存在终结符a使得α和β都能够推导出以a开头的串

2.α和β至多有一个能推导出ε

3.如果 β→* ε，则FIRST (α)∩FOLLOW(A) =Φ

4.如果 α→*ε，则FIRST (β)∩FOLLOW(A) =Φ

同一非终结符的各个产生式互不相交，因此可为LL（1）文法构造预测分析器

第一个“L”表示从左向右扫描输入，第二个“ L”表示产生最左推导，“1”表示在每一步中只需要向前看一个输入符号来决定语法分析动作

### First集和Follow集计算

计算First集时不断应用下列规则，直到没有新的终结符或ε可以被加入到任何FIRST集合中为止

1.如果X是一个终结符，那么FIRST ( X ) = { X }

2.如果X是一个非终结符，且 X→Y1…Yk∈P(k≥1)，那么如果对于某个i，a在FIRST(Yi ) 中且ε 在所有的FIRST(Y1) , … , FIRST(Yi-1)中(即Y1...Yi-1 →* ε)，就把a加入到FIRST( X )中。如果对于所有的 j = 1,2, . . . , k，ε在FIRST(Yj)中，那么将ε加入到FIRST( X )

3.如果 X→ε∈P，那么将ε加入到FIRST( X )中

### 计算算串X1X2…Xn的FIRST 集合

向FIRST(X1X2…Xn)加入FIRST(X1)中所有的非ε符号

如果ε在FIRST(X1)中，再加入FIRST(X2)中的所有非ε符号；如果ε在FIRST(X1)
和FIRST(X2)中，再加入FIRST(X3)中的所有非ε符号，以此类推

最后，如果对所有的i，ε都在FIRST(Xi)中，那么将ε加入到FIRST(X1X2…Xn) 中

例子：

![](C:\Users\27923\Desktop\编译原理\微信截图_20250101151448.png)



### 计算非终结符的Follow集

不断应用下列规则，直到没有新的终结符可以被加入到任何FOLLOW集合中为止

将$放入FOLLOW( S )中，其中S是开始符号，$是输入右端的结束标记

如果存在一个产生式A→αBβ，那么FIRST ( β)中除ε 之外的所有符号都在FOLLOW( B )中

如果存在一个产生式A→αB，或存在产生式A→αBβ且FIRST ( β ) 包含ε，那么 FOLLOW( A )中的所有符号都在FOLLOW( B )中

Follow集中无空串

例子：

![](C:\Users\27923\Desktop\编译原理\微信截图_20250101151851.png)

由此可得：

![](C:\Users\27923\Desktop\编译原理\微信截图_20250101152424.png)

该文法的Select集为：

![](C:\Users\27923\Desktop\编译原理\微信截图_20250101152517.png)

预测分析表为：

![](C:\Users\27923\Desktop\编译原理\微信截图_20250101152608.png)

### 递归的预测分析法

在递归下降分析中，根据预测分析表进行产生式的选择

根据每个非终结符的产生式和LL(1)文法的预测分析表，为每个非终结符编写对应的过程

### 非递归的预测分析法

非递归的预测分析不需要为每个非终结符编写递归下降过程，而是根据预测分析表构造一个自动机，也叫表驱动的预测分析

![](C:\Users\27923\Desktop\编译原理\微信截图_20250107114348.png)

### 两者比较

![](C:\Users\27923\Desktop\编译原理\微信截图_20250107114748.png)

### 预测分析法实现步骤

1.构造文法
2.改造文法：消除二义性、消除左递归、消除回溯
3.求每个变量的FIRST集和FOLLOW集，从而求得每个候选式的SELECT集
4.检查是不是 LL(1) 文法。若是，构造预测分析表
5.对于递归的预测分析，根据预测分析表为每一个非终结符编写一个过程；对于非递归的预测分析，实现表驱动的预测分析算法

### 预测分析中的错误检测

检测错误的情况有两种：

1.栈顶的终结符和当前输入符号不匹配

2.栈顶非终结符与当前输入符号在预测分析表对应项中的信息为空

### 预测分析中的错误恢复

使用恐慌模式（忽略输入中的一些符号，直至出现合法的词法单元为止），但由于这种方式恢复起来较慢，若无合法词法单元，分析器会一直搜索下去，因此可以为非终结符选定合法的同步词法单元，使得语法分析器能够从实际遇到的错误快速恢复

例如栈顶是非终结符A，可以把FOLLOW（A）中所有的终结符设置为非终结符A的同步词法单元。

若栈顶是终结符且不能匹配，则直接弹出此终结符

例子：

![](C:\Users\27923\Desktop\编译原理\微信截图_20250107121229.png)

分析表的用法：

若[A,a]是空，表示检测到错误，根据恐慌模式，忽略输入符号a

若[A,a]是synch，则弹出栈顶的非终结符A，试图继续分析后面的语法成分

若栈顶的终结符和输入符号不匹配，则弹出栈顶的终结符

例子：

![](C:\Users\27923\Desktop\编译原理\微信截图_20250107121620.png)
